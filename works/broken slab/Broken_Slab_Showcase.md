In an attempt to not only improve my technical knowledge, but also keep the momentum of earlier comp courses going, I took a scripting in videogames class in fall of 2024. This wasn't a required course, but it was something that I felt would be important personally. the course itself ran through some of the same concepts we learned in our comp courses, however under the context of Unreal Engine Blueprints. it would also later cover more advanced topics specific to the engine like timelines, UI, and more. 

The major final assignment was where things got interesting, as we were required to either do a group project, or a solo project of remaking a mechanic from an existing videogame as closely as possible. As should be evident by now, i went with the latter.

<video controls src="final submission1983-8175.mp4" title="Title"></video>

The time travel mechanic from Dishonored 2 felt like the perfect goal for the assignment. Simple enough to plan out and break up into its individual elements, but just complicated enough to force me to learn some new things on my own. As i started the assignment, i had already used level streaming in a personal project in the past, so i figured it would be a good starting off point. While tutorials for this kind of mechanic in unreal did exist, i avoided using them for two main reasons:
1. The revolved around essentially building two levels in the same unreal scene, which felt like an unoptimized approach i could improve on.
2. I didn't bother to check until the assignment was already completed, mistakenly believing this to be an incredibly niche thing to want to make in unreal.
needless to say, i was already full speed ahead on my implementation, and it was much more fun to look at documentation for individual pieces and try putting them together like that than it was to blindly follow a tutorial.

# Earliest Progress
Unfortunately, I don't have a ton of pictures or clips from this early stage. I only started recording when i got the timepiece working.

I started this project out like i do a lot of personal projects: remaking the same first person character in a blank template i taught myself to make years ago at this point. As much as i bashed on tutorials above, this one was still based on a basic FPS movement system showed off by Matthew Palaje on youtube that I adapted to work with the new unreal input system. on top of that, for a bit of extra polish, I added a custom Quake style camera tilter that used the characters velocity translated through their local right vector as the intensity of this turn. after that, i just had to plug it into a mapped ranged clamp that would in turn be plugged into the tick update for rotating the camera on its local roll. After this, i did have to come up with a timeline based event that turned the camera roll back to zero whenever the character wasn't in the air. Its a bit hacky, but i didn't really have any issues with this.

Now despite saying i was using level streaming as a jumping off point, i only started out with loading in both instances at once since i still had to debug things. the first order of business was the mirror object. In Dishonored, the mirror shows the other level in real time from the exact parallel perspective of the player. i figured the best way to do this in unreal was by creating a mirror player class that copied the same transform and look direction of the real player, but offset it to the levels location. in the end, this offset did have to be hardcoded into the game mode, but it was inconsequential for the most part. after that was all set and done, i had to actually render the other scene onto the mirror object in the players hand.

The mirror was a pretty basic model made in Blender that was Projection Unwrapped. this was done with the expectation that the scene was going to have to render on top unaltered. After this i did a bit of research into Render Targets at the suggestion of a friend. This ended up being the method i used to render the scene to the timepiece, and it looked really good. not only that, but it was extremely simple being an object that renders to a texture, and then a material that actually uses that texture.

<video controls src="RenderTargets.mp4" title="Title"></video>

After this i could finally work on the actual teleportation part of this. Why did i wait this long to start the more important part? Mainly because i needed some kind of setup to actually test what i was even doing. That aside, the actual teleport came down to just swapping positions of the mirror character and the main character as well as negating the offset so the mirror character doesn't fly off into the void.
<video controls src="swapping.mp4" title="Title"></video>

now you may or may not have noticed a bit of a problem here. while the scene does project fine onto the time piece, its not positioned correctly at all. In the first clip, the middle of the camera view was mapped to the middle of the windows UV. in the clip above, i offset the UV in the render target material to more closely match to the center of the screen instead of the object. this worked fine at first, but its easy to see where things can go wrong. all it takes to destroy the effect in this case is a differently sized monitor or game window. it took another day or so of messing around, but i eventually did find a solution to this. the first part involved using the screen position node in the material shader to map the render target to the screen, entirely ignoring object UVs altogether, but this alone didn't fix everything, and instead i had to make the render target be a 16:9 texture rather than a perfect square. while it looked perfect now, it still wasn't ideal as the resolution was still hardcoded. while it could work fine for most people, if my TAs were using a MacBook with a 16:10 screen, or if i decided to port it to the steam deck, it would fit improperly. the solution was to create a dynamic material instance in the mirror characters blueprint and set the texture resolution there to whatever the resolution of the game window was. for added performance, i divided this by 8 which was far lighter on my laptops GPU.

for a bit of polish, i also made a transition animation as the player teleports. in the above video, it mostly just cleanly switches scenes without much fanfare, and it was hard for some of the people i showed it to to even notice. the solution was to make a timeline event that slowed down time, increased FOV, increased film grain, and desaturated the whole scene all before swapping and reverting the changes. this made it look much more like dishonored and i was extremely happy with the result.

<video controls src="improved teleport.mp4" title="Title"></video>

you may notice in that video, the other levels were also popping in and out of existence. this was another thing i worked on that day. i had the game mode keep track of whether or not the timepiece was open or not. if it wasn't, it would just take whichever level the the player wasn't in and unload it from the persistent level. while the performance hit of having both loaded at once was rather negligible on my desktop rig with a 3060, it was quite painful on my school laptop with a significantly weaker rx6500m, so this felt very justified in development.

after that, it mostly came down to fleshing out a basic level with an end goal. despite how quickly i had been making progress up until this point, i did slow down significantly at this point, and was fairly rough with some of the final touches.
![basic box scene with quixel textures and some simple scene assets](<scene demo.png>)

the level design was fairly basic, but i used that to my advantage. as a level gimmick, i had one level set in early production that looked like a basic white box layout. the other, i textured properly and included vital things like exits and a level goal. the whole idea was you had to go back and forth in time to get to the level goal.

as for what this goal was, it was basically a glorified collectible. the player would bump into it, it would fall to the ground, and then it would disappear. due to level streaming, i did have to implement a check on construction that would delete the actor if it detected it had already been collected in the game mode. it was minorly annoying, but far from the only issue that cropped up this late.

the very last thing i tackled before submitting was the task of adding enemies, and this is where i had to compromise. remember when i said nobody really used level streaming in their tutorials? turns out it was probably for good reason. if both levels are running simultaneously, then you can just dot the levels with regular enemies that continue to exist even after the player switches time periods. thanks to my approach of using level streaming, i ended up having to make enemies that stored their location, death state, and ID in a struct that would be stored in the game mode to be pulled on level load. at least, this was the initial plan. try as i might, i was never able to get any of this to work. with the deadline and class showcase rapidly approaching, i had to cut enemies before i even added any way of neutralizing them. thankfully, things still turned out well, and it was a minor enough detail that it didn't really matter in the end. that said, it did still teach an extremely valid lesson about hubris and how simplicity will always work better long term than the cooler and more complex things.